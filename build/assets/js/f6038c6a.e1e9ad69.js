"use strict";(globalThis.webpackChunklearningbook=globalThis.webpackChunklearningbook||[]).push([[80],{8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>r});var a=i(6540);const t={},s=a.createContext(t);function l(n){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),a.createElement(s.Provider,{value:e},n.children)}},8541:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"chapters/intelligence/planning-and-reasoning","title":"Lesson 4.1: Planning and Reasoning","description":"High-level planning algorithms, task planning, and reasoning systems that enable humanoid robots to perform complex, multi-step tasks","source":"@site/docs/chapters/04-intelligence/01-planning-and-reasoning.mdx","sourceDirName":"chapters/04-intelligence","slug":"/chapters/intelligence/planning-and-reasoning","permalink":"/docs/chapters/intelligence/planning-and-reasoning","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapters/04-intelligence/01-planning-and-reasoning.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Lesson 4.1: Planning and Reasoning","sidebar_label":"Planning and Reasoning","description":"High-level planning algorithms, task planning, and reasoning systems that enable humanoid robots to perform complex, multi-step tasks","keywords":["planning","reasoning","task planning","logic programming","AI reasoning"]},"sidebar":"docsSidebar","previous":{"title":"Learning-Based Control","permalink":"/docs/chapters/control/learning-based-control"},"next":{"title":"Planning and Reasoning","permalink":"/docs/chapters/intelligence/planning-and-reasoning"}}');var t=i(4848),s=i(8453);const l={title:"Lesson 4.1: Planning and Reasoning",sidebar_label:"Planning and Reasoning",description:"High-level planning algorithms, task planning, and reasoning systems that enable humanoid robots to perform complex, multi-step tasks",keywords:["planning","reasoning","task planning","logic programming","AI reasoning"]},r="Lesson 4.1: Planning and Reasoning",o={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Theoretical Foundation",id:"theoretical-foundation",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Practical Application",id:"practical-application",level:2},{value:"Example 1: Basic Task Planner",id:"example-1-basic-task-planner",level:3},{value:"Example 2: Logical Reasoning System",id:"example-2-logical-reasoning-system",level:3},{value:"Implementation Guide",id:"implementation-guide",level:2},{value:"Step 1: Setup",id:"step-1-setup",level:3},{value:"Step 2: Implementation",id:"step-2-implementation",level:3},{value:"Step 3: Testing",id:"step-3-testing",level:3},{value:"Hands-on Exercise",id:"hands-on-exercise",level:2},{value:"Exercise Requirements",id:"exercise-requirements",level:3},{value:"Verification",id:"verification",level:2},{value:"Troubleshooting Guide",id:"troubleshooting-guide",level:2},{value:"Real-World Relevance",id:"real-world-relevance",level:2},{value:"Safety Considerations",id:"safety-considerations",level:2},{value:"Further Exploration",id:"further-exploration",level:2},{value:"Summary",id:"summary",level:2},{value:"Knowledge Check",id:"knowledge-check",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"lesson-41-planning-and-reasoning",children:"Lesson 4.1: Planning and Reasoning"})}),"\n",(0,t.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(e.p,{children:"Planning and reasoning systems are crucial for enabling humanoid robots to perform complex, multi-step tasks by breaking them down into manageable subtasks and executing them in the correct sequence. This lesson explores high-level planning algorithms, task planning techniques, and reasoning systems that allow robots to think ahead and make intelligent decisions."}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(e.p,{children:"After completing this lesson, students will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understand the fundamentals of automated planning for robotics"}),"\n",(0,t.jsx)(e.li,{children:"Implement basic task planning algorithms"}),"\n",(0,t.jsx)(e.li,{children:"Apply logical reasoning techniques for robot decision-making"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsx)(e.p,{children:"Students should have knowledge of:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Basic understanding of artificial intelligence concepts"}),"\n",(0,t.jsx)(e.li,{children:"Programming skills in Python"}),"\n",(0,t.jsx)(e.li,{children:"Familiarity with logic and formal reasoning"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"theoretical-foundation",children:"Theoretical Foundation"}),"\n",(0,t.jsx)(e.p,{children:"Planning and reasoning systems for humanoid robots must handle complex, multi-step tasks that require both high-level strategic thinking and low-level execution. These systems bridge the gap between abstract goals and concrete actions."}),"\n",(0,t.jsx)(e.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Task Planning"}),": Breaking down complex goals into sequences of executable actions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Hierarchical Planning"}),": Organizing plans at multiple levels of abstraction"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Logical Reasoning"}),": Using formal logic to make decisions and draw conclusions"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"practical-application",children:"Practical Application"}),"\n",(0,t.jsx)(e.p,{children:"Let's explore planning and reasoning systems with practical examples:"}),"\n",(0,t.jsx)(e.h3,{id:"example-1-basic-task-planner",children:"Example 1: Basic Task Planner"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'from typing import List, Dict, Set, Tuple, Optional\nfrom dataclasses import dataclass\nfrom enum import Enum\n\n@dataclass\nclass Action:\n    name: str\n    preconditions: Set[str]\n    effects: Set[str]\n    cost: int = 1\n\n@dataclass\nclass Task:\n    name: str\n    goal_conditions: Set[str]\n\nclass SimplePlanner:\n    def __init__(self):\n        self.actions: List[Action] = []\n        self.current_state: Set[str] = set()\n\n    def add_action(self, action: Action):\n        """Add an action to the planner\'s repertoire"""\n        self.actions.append(action)\n\n    def set_initial_state(self, state: Set[str]):\n        """Set the initial state of the world"""\n        self.current_state = state.copy()\n\n    def is_goal_satisfied(self, goal_conditions: Set[str], state: Set[str]) -> bool:\n        """Check if all goal conditions are satisfied in the given state"""\n        return goal_conditions.issubset(state)\n\n    def find_applicable_actions(self, state: Set[str]) -> List[Action]:\n        """Find all actions that can be applied in the current state"""\n        applicable = []\n        for action in self.actions:\n            if action.preconditions.issubset(state):\n                applicable.append(action)\n        return applicable\n\n    def execute_action(self, action: Action, state: Set[str]) -> Set[str]:\n        """Execute an action and return the new state"""\n        new_state = state.copy()\n        # Remove effects that start with \'not_\'\n        for effect in action.effects:\n            if effect.startswith(\'not_\'):\n                negated_fact = effect[4:]  # Remove \'not_\' prefix\n                new_state.discard(negated_fact)\n            else:\n                new_state.add(effect)\n        return new_state\n\n    def plan_to_goal(self, goal_conditions: Set[str]) -> Optional[List[Action]]:\n        """Find a plan to achieve the goal conditions using breadth-first search"""\n        # Check if goal is already satisfied\n        if self.is_goal_satisfied(goal_conditions, self.current_state):\n            return []\n\n        # Use breadth-first search to find a plan\n        queue = [(self.current_state, [])]  # (state, plan)\n        visited = {tuple(sorted(self.current_state))}\n\n        while queue:\n            current_state, current_plan = queue.pop(0)\n\n            # Find applicable actions\n            applicable_actions = self.find_applicable_actions(current_state)\n\n            for action in applicable_actions:\n                new_state = self.execute_action(action, current_state)\n                new_plan = current_plan + [action]\n\n                # Check if goal is satisfied\n                if self.is_goal_satisfied(goal_conditions, new_state):\n                    return new_plan\n\n                # Check if this state has been visited\n                state_key = tuple(sorted(new_state))\n                if state_key not in visited:\n                    visited.add(state_key)\n                    queue.append((new_state, new_plan))\n\n        return None  # No plan found\n\n# Example usage: Robot kitchen task\nplanner = SimplePlanner()\n\n# Define actions for a simple kitchen scenario\nplanner.add_action(Action(\n    name="pick_up_cup",\n    preconditions={"at_kitchen", "cup_on_table", "arm_free"},\n    effects={"holding_cup", "not_arm_free", "not_cup_on_table"}\n))\n\nplanner.add_action(Action(\n    name="go_to_kitchen",\n    preconditions=set(),\n    effects={"at_kitchen"}\n))\n\nplanner.add_action(Action(\n    name="fill_cup",\n    preconditions={"holding_cup", "at_kitchen", "water_available"},\n    effects={"cup_filled"}\n))\n\nplanner.add_action(Action(\n    name="deliver_cup",\n    preconditions={"cup_filled", "holding_cup"},\n    effects={"cup_delivered", "arm_free", "not_holding_cup"}\n))\n\n# Set initial state\nplanner.set_initial_state({"water_available", "cup_on_table"})\n\n# Define goal\ngoal = {"cup_delivered"}\n\n# Plan to achieve goal\nplan = planner.plan_to_goal(goal)\n\nif plan:\n    print(f"Found plan with {len(plan)} actions:")\n    for i, action in enumerate(plan):\n        print(f"  {i+1}. {action.name}")\nelse:\n    print("No plan found")\n'})}),"\n",(0,t.jsx)(e.h3,{id:"example-2-logical-reasoning-system",children:"Example 2: Logical Reasoning System"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'from typing import Dict, List, Set, Tuple, Any\nfrom dataclasses import dataclass\n\n@dataclass\nclass Predicate:\n    """A logical predicate with name and arguments"""\n    name: str\n    args: List[str]\n\n@dataclass\nclass Rule:\n    """A logical rule with head and body"""\n    head: Predicate\n    body: List[Predicate]\n\nclass KnowledgeBase:\n    def __init__(self):\n        self.facts: Set[Tuple[str, ...]] = set()\n        self.rules: List[Rule] = []\n\n    def add_fact(self, predicate: Predicate):\n        """Add a fact to the knowledge base"""\n        self.facts.add((predicate.name, *predicate.args))\n\n    def add_rule(self, rule: Rule):\n        """Add a rule to the knowledge base"""\n        self.rules.append(rule)\n\n    def query(self, predicate: Predicate) -> bool:\n        """Query if a predicate is true given the knowledge base"""\n        # Check if fact exists directly\n        if (predicate.name, *predicate.args) in self.facts:\n            return True\n\n        # Try to derive using rules\n        for rule in self.rules:\n            if self._unify_and_derive(rule, predicate):\n                return True\n\n        return False\n\n    def _unify_and_derive(self, rule: Rule, query: Predicate) -> bool:\n        """Try to unify the rule head with the query and derive if possible"""\n        # Simple unification for same predicate name and matching arguments\n        if rule.head.name == query.name:\n            # Check if we can match the arguments\n            if len(rule.head.args) == len(query.args):\n                # For this simple example, assume direct match or variables\n                # In a full implementation, you\'d do proper unification\n                return all(\n                    rule_head_arg == query_arg or rule_head_arg.startswith(\'?\')\n                    for rule_head_arg, query_arg in zip(rule.head.args, query.args)\n                )\n\n        return False\n\n    def forward_chain(self) -> Set[Tuple[str, ...]]:\n        """Perform forward chaining to derive all possible facts"""\n        new_facts = set(self.facts)\n\n        changed = True\n        while changed:\n            changed = False\n            current_facts = set(new_facts)\n\n            for rule in self.rules:\n                # Check if all body predicates are satisfied\n                body_satisfied = True\n                for body_pred in rule.body:\n                    if (body_pred.name, *body_pred.args) not in current_facts:\n                        body_satisfied = False\n                        break\n\n                if body_satisfied:\n                    # Add the head predicate if not already present\n                    head_fact = (rule.head.name, *rule.head.args)\n                    if head_fact not in new_facts:\n                        new_facts.add(head_fact)\n                        changed = True\n\n        return new_facts\n\nclass RobotReasoner:\n    def __init__(self):\n        self.kb = KnowledgeBase()\n        self.setup_knowledge_base()\n\n    def setup_knowledge_base(self):\n        """Set up the initial knowledge base for the robot"""\n        # Add facts about the environment\n        self.kb.add_fact(Predicate("at", ["robot", "kitchen"]))\n        self.kb.add_fact(Predicate("at", ["cup", "table"]))\n        self.kb.add_fact(Predicate("available", ["water"]))\n        self.kb.add_fact(Predicate("free", ["arm"]))\n\n        # Add rules for reasoning\n        self.kb.add_rule(Rule(\n            head=Predicate("can_pick_up", ["X", "Y"]),\n            body=[Predicate("at", ["X", "location"]),\n                  Predicate("at", ["Y", "location"]),\n                  Predicate("free", ["X"])]\n        ))\n\n        self.kb.add_rule(Rule(\n            head=Predicate("can_reach", ["X", "Y"]),\n            body=[Predicate("at", ["X", "location"]),\n                  Predicate("at", ["Y", "location"])]\n        ))\n\n        self.kb.add_rule(Rule(\n            head=Predicate("can_pour", ["X", "Y", "Z"]),\n            body=[Predicate("holding", ["X"]),\n                  Predicate("available", ["Y"]),\n                  Predicate("container", ["Z"])]\n        ))\n\n    def can_perform_action(self, action: str, args: List[str]) -> bool:\n        """Check if the robot can perform a specific action"""\n        if action == "pick_up":\n            return self.kb.query(Predicate("can_pick_up", args))\n        elif action == "reach":\n            return self.kb.query(Predicate("can_reach", args))\n        else:\n            # For other actions, check if they\'re directly possible\n            return self.kb.query(Predicate(action, args))\n\n    def get_environment_state(self) -> Set[Tuple[str, ...]]:\n        """Get all derived facts about the environment"""\n        return self.kb.forward_chain()\n\n# Example usage\nreasoner = RobotReasoner()\n\n# Query the knowledge base\ncan_pick_up = reasoner.can_perform_action("pick_up", ["robot", "cup"])\nprint(f"Can robot pick up cup? {can_pick_up}")\n\ncan_reach = reasoner.can_perform_action("reach", ["robot", "cup"])\nprint(f"Can robot reach cup? {can_reach}")\n\n# Get all derived facts\nall_facts = reasoner.get_environment_state()\nprint(f"All derived facts: {all_facts}")\n'})}),"\n",(0,t.jsx)(e.h2,{id:"implementation-guide",children:"Implementation Guide"}),"\n",(0,t.jsx)(e.h3,{id:"step-1-setup",children:"Step 1: Setup"}),"\n",(0,t.jsx)(e.p,{children:"For planning and reasoning systems, you'll need basic Python libraries:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"pip install numpy\n"})}),"\n",(0,t.jsx)(e.h3,{id:"step-2-implementation",children:"Step 2: Implementation"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Define the planning domain (actions, preconditions, effects)"}),"\n",(0,t.jsx)(e.li,{children:"Implement planning algorithms (STRIPS, PDDL, etc.)"}),"\n",(0,t.jsx)(e.li,{children:"Create reasoning systems with knowledge bases"}),"\n",(0,t.jsx)(e.li,{children:"Add planning and reasoning integration"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"step-3-testing",children:"Step 3: Testing"}),"\n",(0,t.jsx)(e.p,{children:"Validate your implementation by:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Testing with simple planning problems"}),"\n",(0,t.jsx)(e.li,{children:"Verifying reasoning correctness"}),"\n",(0,t.jsx)(e.li,{children:"Measuring planning efficiency"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"hands-on-exercise",children:"Hands-on Exercise"}),"\n",(0,t.jsx)(e.p,{children:"Implement a basic planning and reasoning system:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Task 1"}),": Create a simple STRIPS-style planner for a robot task"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Task 2"}),": Implement a logical reasoning system with facts and rules"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Task 3"}),": Integrate planning and reasoning for complex task execution"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"exercise-requirements",children:"Exercise Requirements"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Support planning with multiple preconditions and effects"}),"\n",(0,t.jsx)(e.li,{children:"Include logical reasoning with forward chaining"}),"\n",(0,t.jsx)(e.li,{children:"Implement plan execution monitoring"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"verification",children:"Verification"}),"\n",(0,t.jsx)(e.p,{children:"How to test and validate the implementation:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Test planning with various goal configurations"}),"\n",(0,t.jsx)(e.li,{children:"Verify reasoning correctness with logical queries"}),"\n",(0,t.jsx)(e.li,{children:"Measure planning time and solution quality"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"troubleshooting-guide",children:"Troubleshooting Guide"}),"\n",(0,t.jsx)(e.p,{children:"Common issues and solutions:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Issue 1"}),": Planner taking too long to find solutions","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Solution: Implement heuristic search or planning hierarchies"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Issue 2"}),": Reasoning system giving incorrect conclusions","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Solution: Verify rule correctness and add proper constraints"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Issue 3"}),": Plans failing during execution","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Solution: Add plan monitoring and replanning capabilities"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"real-world-relevance",children:"Real-World Relevance"}),"\n",(0,t.jsx)(e.p,{children:"Planning and reasoning are essential in humanoid robotics for:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Executing complex multi-step tasks"}),"\n",(0,t.jsx)(e.li,{children:"Making intelligent decisions in dynamic environments"}),"\n",(0,t.jsx)(e.li,{children:"Interacting with humans and objects safely"}),"\n",(0,t.jsx)(e.li,{children:"Adapting to unexpected situations"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,t.jsx)(e.p,{children:"When working with planning and reasoning systems:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Ensure safety constraints are included in planning"}),"\n",(0,t.jsx)(e.li,{children:"Verify that reasoning leads to safe actions"}),"\n",(0,t.jsx)(e.li,{children:"Implement fallback plans for critical situations"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"further-exploration",children:"Further Exploration"}),"\n",(0,t.jsx)(e.p,{children:"Advanced topics and additional resources for students who want to dive deeper:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Study of PDDL (Planning Domain Definition Language) for complex planning"}),"\n",(0,t.jsx)(e.li,{children:"Research into hierarchical task networks (HTN) planning"}),"\n",(0,t.jsx)(e.li,{children:"Exploration of probabilistic reasoning systems"}),"\n",(0,t.jsx)(e.li,{children:"Investigation of planning under uncertainty"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"This lesson covered the fundamentals of planning and reasoning for humanoid robots, including task planning algorithms and logical reasoning systems that enable robots to perform complex, multi-step tasks."}),"\n",(0,t.jsx)(e.h2,{id:"knowledge-check",children:"Knowledge Check"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Question 1: What is the difference between planning and scheduling in robotics?"}),"\n",(0,t.jsx)(e.li,{children:"Question 2: How do preconditions and effects work in STRIPS-style planning?"}),"\n",(0,t.jsx)(e.li,{children:"Question 3: What are the challenges of planning for humanoid robots compared to simple agents?"}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}}}]);