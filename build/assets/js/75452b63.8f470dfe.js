"use strict";(globalThis.webpackChunklearningbook=globalThis.webpackChunklearningbook||[]).push([[1631],{4052:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"chapters/control/motion-planning","title":"Lesson 3.1: Motion Planning and Pathfinding","description":"Algorithms for planning robot movements in 3D space, obstacle avoidance, and trajectory optimization for humanoid robots","source":"@site/docs/chapters/03-control/01-motion-planning.mdx","sourceDirName":"chapters/03-control","slug":"/chapters/control/motion-planning","permalink":"/docs/chapters/control/motion-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapters/03-control/01-motion-planning.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Lesson 3.1: Motion Planning and Pathfinding","sidebar_label":"Motion Planning and Pathfinding","description":"Algorithms for planning robot movements in 3D space, obstacle avoidance, and trajectory optimization for humanoid robots","keywords":["motion planning","pathfinding","trajectory optimization","humanoid control"]},"sidebar":"docsSidebar","previous":{"title":"Multi-modal Perception","permalink":"/docs/chapters/perception/multi-modal-perception"},"next":{"title":"Motion Planning and Pathfinding","permalink":"/docs/chapters/control/motion-planning"}}');var o=i(4848),a=i(8453);const s={title:"Lesson 3.1: Motion Planning and Pathfinding",sidebar_label:"Motion Planning and Pathfinding",description:"Algorithms for planning robot movements in 3D space, obstacle avoidance, and trajectory optimization for humanoid robots",keywords:["motion planning","pathfinding","trajectory optimization","humanoid control"]},r="Lesson 3.1: Motion Planning and Pathfinding",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Theoretical Foundation",id:"theoretical-foundation",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Practical Application",id:"practical-application",level:2},{value:"Example 1: Basic Path Planning in 2D",id:"example-1-basic-path-planning-in-2d",level:3},{value:"Example 2: Trajectory Optimization for Smooth Motion",id:"example-2-trajectory-optimization-for-smooth-motion",level:3},{value:"Implementation Guide",id:"implementation-guide",level:2},{value:"Step 1: Setup",id:"step-1-setup",level:3},{value:"Step 2: Implementation",id:"step-2-implementation",level:3},{value:"Step 3: Testing",id:"step-3-testing",level:3},{value:"Hands-on Exercise",id:"hands-on-exercise",level:2},{value:"Exercise Requirements",id:"exercise-requirements",level:3},{value:"Verification",id:"verification",level:2},{value:"Troubleshooting Guide",id:"troubleshooting-guide",level:2},{value:"Real-World Relevance",id:"real-world-relevance",level:2},{value:"Safety Considerations",id:"safety-considerations",level:2},{value:"Further Exploration",id:"further-exploration",level:2},{value:"Summary",id:"summary",level:2},{value:"Knowledge Check",id:"knowledge-check",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"lesson-31-motion-planning-and-pathfinding",children:"Lesson 3.1: Motion Planning and Pathfinding"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(e.p,{children:"Motion planning is a fundamental challenge in humanoid robotics, involving the computation of feasible and optimal paths for robots to move from one configuration to another while avoiding obstacles and satisfying various constraints. This lesson explores the core algorithms and techniques used for motion planning in 3D space, with special considerations for humanoid robots."}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(e.p,{children:"After completing this lesson, students will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Understand the fundamentals of motion planning algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Implement basic pathfinding algorithms for humanoid robots"}),"\n",(0,o.jsx)(e.li,{children:"Apply trajectory optimization techniques for smooth motion"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsx)(e.p,{children:"Students should have knowledge of:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Basic understanding of kinematics and robot configurations"}),"\n",(0,o.jsx)(e.li,{children:"Programming skills in Python"}),"\n",(0,o.jsx)(e.li,{children:"Fundamentals of graph theory and search algorithms"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"theoretical-foundation",children:"Theoretical Foundation"}),"\n",(0,o.jsx)(e.p,{children:"Motion planning in humanoid robots is more complex than in wheeled robots due to the need to consider the full 3D configuration space, including the position and orientation of multiple joints. The planning must account for the robot's complex kinematic structure and dynamic constraints."}),"\n",(0,o.jsx)(e.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Configuration Space (C-space)"}),": The space of all possible robot configurations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Collision Detection"}),": Identifying when the robot intersects with obstacles"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Path Optimization"}),": Finding paths that are not just feasible but also optimal according to some criteria"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"practical-application",children:"Practical Application"}),"\n",(0,o.jsx)(e.p,{children:"Let's explore motion planning algorithms with practical examples:"}),"\n",(0,o.jsx)(e.h3,{id:"example-1-basic-path-planning-in-2d",children:"Example 1: Basic Path Planning in 2D"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import numpy as np\nimport matplotlib.pyplot as plt\nfrom typing import List, Tuple, Optional\nimport heapq\n\nclass GridMap:\n    def __init__(self, width: int, height: int):\n        self.width = width\n        self.height = height\n        self.grid = np.zeros((height, width), dtype=int)  # 0 = free, 1 = obstacle\n\n    def set_obstacle(self, x: int, y: int):\n        if 0 <= x < self.width and 0 <= y < self.height:\n            self.grid[y, x] = 1\n\n    def is_free(self, x: int, y: int) -> bool:\n        if 0 <= x < self.width and 0 <= y < self.height:\n            return self.grid[y, x] == 0\n        return False\n\nclass AStarPlanner:\n    def __init__(self, grid_map: GridMap):\n        self.grid_map = grid_map\n        self.directions = [(-1, 0), (1, 0), (0, -1), (0, 1),  # 4-connected\n                          (-1, -1), (-1, 1), (1, -1), (1, 1)]  # Diagonal\n\n    def heuristic(self, a: Tuple[int, int], b: Tuple[int, int]) -> float:\n        """Manhattan distance heuristic"""\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def plan_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> Optional[List[Tuple[int, int]]]:\n        """Plan path using A* algorithm"""\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = {start: 0}\n        f_score = {start: self.heuristic(start, goal)}\n\n        while open_set:\n            current = heapq.heappop(open_set)[1]\n\n            if current == goal:\n                # Reconstruct path\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]  # Reverse to get start-to-goal path\n\n            for dx, dy in self.directions:\n                neighbor = (current[0] + dx, current[1] + dy)\n\n                if not self.grid_map.is_free(neighbor[0], neighbor[1]):\n                    continue\n\n                tentative_g_score = g_score[current] + np.sqrt(dx*dx + dy*dy)\n\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + self.heuristic(neighbor, goal)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n        return None  # No path found\n\n# Example usage\ngrid = GridMap(20, 15)\n\n# Add some obstacles\nfor i in range(5, 15):\n    grid.set_obstacle(i, 7)  # Horizontal wall\n\n# Plan path\nplanner = AStarPlanner(grid)\npath = planner.plan_path((2, 2), (18, 12))\n\nif path:\n    print(f"Found path with {len(path)} steps")\n    for i, point in enumerate(path):\n        if i % 5 == 0:  # Print every 5th point\n            print(f"Step {i}: {point}")\nelse:\n    print("No path found")\n'})}),"\n",(0,o.jsx)(e.h3,{id:"example-2-trajectory-optimization-for-smooth-motion",children:"Example 2: Trajectory Optimization for Smooth Motion"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\nclass TrajectoryOptimizer:\n    def __init__(self, start_pos, goal_pos, num_waypoints=10):\n        self.start_pos = np.array(start_pos)\n        self.goal_pos = np.array(goal_pos)\n        self.num_waypoints = num_waypoints\n\n    def objective_function(self, waypoints_flat):\n        """Minimize path length and smoothness"""\n        # Reshape flat array back to waypoints\n        waypoints = waypoints_flat.reshape(self.num_waypoints, 2)\n\n        # Add start and goal to trajectory\n        full_trajectory = np.vstack([self.start_pos, waypoints, self.goal_pos])\n\n        # Calculate path length\n        path_length = 0\n        for i in range(len(full_trajectory) - 1):\n            path_length += np.linalg.norm(full_trajectory[i+1] - full_trajectory[i])\n\n        # Calculate smoothness (minimize acceleration)\n        smoothness = 0\n        for i in range(1, len(full_trajectory) - 1):\n            prev_point = full_trajectory[i-1]\n            curr_point = full_trajectory[i]\n            next_point = full_trajectory[i+1]\n            acceleration = np.linalg.norm((next_point - curr_point) - (curr_point - prev_point))\n            smoothness += acceleration**2\n\n        # Weighted combination of path length and smoothness\n        return path_length + 0.1 * smoothness\n\n    def optimize_trajectory(self):\n        """Optimize trajectory to minimize length and maximize smoothness"""\n        # Initial guess: straight line between start and goal\n        initial_waypoints = []\n        for i in range(1, self.num_waypoints + 1):\n            t = i / (self.num_waypoints + 1)\n            waypoint = self.start_pos + t * (self.goal_pos - self.start_pos)\n            initial_waypoints.extend(waypoint)\n\n        # Optimize\n        result = minimize(\n            self.objective_function,\n            np.array(initial_waypoints),\n            method=\'BFGS\'\n        )\n\n        # Extract optimized waypoints\n        optimized_waypoints = result.x.reshape(self.num_waypoints, 2)\n        full_trajectory = np.vstack([self.start_pos, optimized_waypoints, self.goal_pos])\n\n        return full_trajectory\n\n# Example usage\noptimizer = TrajectoryOptimizer(start_pos=[0, 0], goal_pos=[10, 8])\noptimized_trajectory = optimizer.optimize_trajectory()\n\nprint(f"Optimized trajectory has {len(optimized_trajectory)} points")\nprint(f"Start: {optimized_trajectory[0]}, Goal: {optimized_trajectory[-1]}")\n'})}),"\n",(0,o.jsx)(e.h2,{id:"implementation-guide",children:"Implementation Guide"}),"\n",(0,o.jsx)(e.h3,{id:"step-1-setup",children:"Step 1: Setup"}),"\n",(0,o.jsx)(e.p,{children:"Install necessary libraries for motion planning:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"pip install numpy scipy matplotlib\n"})}),"\n",(0,o.jsx)(e.h3,{id:"step-2-implementation",children:"Step 2: Implementation"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Define the configuration space and environment representation"}),"\n",(0,o.jsx)(e.li,{children:"Implement pathfinding algorithms (A*, RRT, etc.)"}),"\n",(0,o.jsx)(e.li,{children:"Create trajectory optimization routines"}),"\n",(0,o.jsx)(e.li,{children:"Add collision detection and avoidance"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"step-3-testing",children:"Step 3: Testing"}),"\n",(0,o.jsx)(e.p,{children:"Validate your implementation by:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Testing pathfinding in various obstacle configurations"}),"\n",(0,o.jsx)(e.li,{children:"Verifying trajectory smoothness and feasibility"}),"\n",(0,o.jsx)(e.li,{children:"Measuring computation time for real-time applications"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"hands-on-exercise",children:"Hands-on Exercise"}),"\n",(0,o.jsx)(e.p,{children:"Implement a basic motion planning system:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Task 1"}),": Create a grid-based path planner using A* algorithm"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Task 2"}),": Implement trajectory optimization for smooth motion"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Task 3"}),": Add basic obstacle avoidance capabilities"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"exercise-requirements",children:"Exercise Requirements"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Support pathfinding in 2D environments with obstacles"}),"\n",(0,o.jsx)(e.li,{children:"Optimize trajectories for smooth motion"}),"\n",(0,o.jsx)(e.li,{children:"Include basic collision detection"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"verification",children:"Verification"}),"\n",(0,o.jsx)(e.p,{children:"How to test and validate the implementation:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Test pathfinding with various obstacle configurations"}),"\n",(0,o.jsx)(e.li,{children:"Verify trajectory smoothness metrics"}),"\n",(0,o.jsx)(e.li,{children:"Measure computational performance for real-time applications"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-guide",children:"Troubleshooting Guide"}),"\n",(0,o.jsx)(e.p,{children:"Common issues and solutions:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Issue 1"}),": Path planning failing in complex environments","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Solution: Implement more sophisticated algorithms like RRT or PRM"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Issue 2"}),": Trajectories being jerky or non-smooth","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Solution: Adjust optimization weights and add smoothness constraints"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Issue 3"}),": High computational cost affecting real-time performance","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Solution: Use hierarchical planning or pre-computed roadmaps"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"real-world-relevance",children:"Real-World Relevance"}),"\n",(0,o.jsx)(e.p,{children:"Motion planning is essential in humanoid robotics for:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Navigation through complex environments"}),"\n",(0,o.jsx)(e.li,{children:"Manipulation tasks requiring precise motion"}),"\n",(0,o.jsx)(e.li,{children:"Human-robot interaction scenarios"}),"\n",(0,o.jsx)(e.li,{children:"Safe movement around obstacles"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,o.jsx)(e.p,{children:"When working with motion planning systems:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Ensure collision checking for all planned trajectories"}),"\n",(0,o.jsx)(e.li,{children:"Implement safety margins around obstacles"}),"\n",(0,o.jsx)(e.li,{children:"Consider dynamic obstacles and real-time replanning"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"further-exploration",children:"Further Exploration"}),"\n",(0,o.jsx)(e.p,{children:"Advanced topics and additional resources for students who want to dive deeper:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Study of Rapidly-exploring Random Trees (RRT) for high-dimensional spaces"}),"\n",(0,o.jsx)(e.li,{children:"Research into sampling-based motion planning algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Exploration of optimal control for trajectory generation"}),"\n",(0,o.jsx)(e.li,{children:"Investigation of learning-based motion planning approaches"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"This lesson covered the fundamentals of motion planning and pathfinding for humanoid robots, including basic algorithms, trajectory optimization, and practical implementation considerations."}),"\n",(0,o.jsx)(e.h2,{id:"knowledge-check",children:"Knowledge Check"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Question 1: What is the difference between path planning and trajectory planning?"}),"\n",(0,o.jsx)(e.li,{children:"Question 2: How does configuration space differ from Cartesian space in motion planning?"}),"\n",(0,o.jsx)(e.li,{children:"Question 3: What are the challenges of motion planning for humanoid robots compared to wheeled robots?"}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>r});var t=i(6540);const o={},a=t.createContext(o);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);